/*
    Star Game Engine
*/

var se = new Object();

if (typeof window !== 'undefined') {
    window.requestAnimationFrame =  (function(){
        return  window.requestAnimationFrame      ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame    ||
            window.oRequestAnimationFrame      ||
            window.msRequestAnimationFrame     ||
            function(callback){ 
                window.setTimeout(function() { callback(new Date.now());    }, 1000 / 60); 
            };
    })();

    window.cancelAnimationFrame = window.cancelAnimationFrame || 
                               window.mozCancelAnimationFrame 
}



/*
    Factory
*/
se.factory = new Object();

se.factory.rect = function (options){
    var opt = options || {};
    var name = opt.name || '';
    var x = opt.x || 0;
    var y = opt.y || 0;
    var w = opt.w || 10;
    var h = opt.h || 10;
    var img = opt.image_src;
    var fillColor = opt.fillColor || '#6B4226';
    var objoptions = opt.objoptions || {};

    opt.hasRigidbody == null ? hasRigidbody = true : hasRigidbody = opt.hasRigidbody;

    objoptions.vertices = [
        new se.Vector(0, 0),
        new se.Vector(w, 0),
        new se.Vector(w, h),
        new se.Vector(0, h),
    ];

    var obj = new se.GameObject(name, x, y, objoptions);

    if(hasRigidbody)
        obj.setRigidBody( new se.RigidBody({vertices: objoptions.vertices}) );

    // Render
    if(img)
        obj.setRenderer( new se.ImageRenderer(img, w, h) );
    else
        obj.setRenderer( new se.RectRenderer(fillColor, w, h) );
    return obj;
};

se.factory.circle = function (options){
    var opt = options || {};
    var name = opt.name || '';
    var x = opt.x || 0;
    var y = opt.y || 0;
    var radius = opt.radius || 10;
    var objoptions = opt.objoptions || {};
    var maxSides = opt.maxSides || 25;

    opt.hasRigidbody == null ? hasRigidbody = true : hasRigidbody = opt.hasRigidbody;

    var fillColor = opt.fillColor;
    var strokeColor = opt.strokeColor;
    var lineWidth = opt.lineWidth;

    objoptions.vertices = se.factory.createCircleVertices(radius, maxSides);

    var obj = new se.GameObject(name, x, y, objoptions);

    if(hasRigidbody)
        obj.setRigidBody( new se.RigidBody(objoptions) );
    obj.setRenderer( new se.CircleRenderer(radius, fillColor, strokeColor, lineWidth) );
    return obj;
};

se.factory.createCircleVertices = function (radius, maxSides){
    // approximate circles with polygons until true circles implemented in SAT
    var maxSides = maxSides || 25;
    var sides = Math.ceil(Math.max(10, Math.min(maxSides, radius)));

    // optimisation: always use even number of sides (half the number of unique axes)
    if (sides % 2 === 1)
        sides += 1;

    var theta = 2 * Math.PI / sides,
        path = '',
        offset = theta * 0.5;

    for (var i = 0; i < sides; i += 1) {
        var angle = offset + (i * theta),
            xx = Math.cos(angle) * radius,
            yy = Math.sin(angle) * radius;

        path += 'L ' + xx.toFixed(3) + ' ' + yy.toFixed(3) + ' ';
    }
    return Matter.Vertices.fromPath(path);

}

/*
    Extent
*/
se.Extent = function (min_x, min_y, max_x, max_y){
    this.min = {x: min_x, y: min_y};
    this.max = {x: max_x, y: max_y};
};

se.Extent.createEmpty = function() {
    return new se.Extent(Infinity, Infinity, -Infinity, -Infinity);
};

se.Extent.prototype.clone = function(){
    return new se.Extent(
        this.min.x, this.min.y, this.max.x, this.max.y);
}

se.Extent.prototype.move = function(vector){
    this.min.x = vector.x;
    this.min.y = vector.y;
    this.max.x += vector.x;
    this.max.y += vector.y;
    return this;
}

se.Extent.prototype.extend = function(extent2) {
    if (extent2.min.x < this.min.x)
        this.min.x = extent2.min.x;
    if (extent2.max.x > this.max.x)
        this.max.x = extent2.max.x;
    if (extent2.min.y < this.min.y)
        this.min.y = extent2.min.y;
    if (extent2.max.y > this.max.y)
        this.max.y = extent2.max.y;
};

se.Extent.prototype.extendVector = function(vector) {
    if (vector.x < this.min.x)
        this.min.x = vector.x;
    if (vector.x > this.max.x)
        this.max.x = vector.x;
    if (vector.y < this.min.y)
        this.min.y = vector.y;
    if (vector.y > this.max.y)
        this.max.y = vector.y;
};

se.Extent.prototype.extendVectors = function(vectors) {
    for(var i in vectors)
        this.extendVector(vectors[i]);
};

se.Extent.prototype.intersects = function(extent) {
    return this.min.x <= extent.max.x &&
           this.max.x >= extent.min.x &&
           this.min.y <= extent.max.y &&
           this.max.y >= extent.min.y;
};


se.Extent.prototype.getIntersection = function(extent) {
    var intersection = se.Extent.createEmpty();
    if (this.intersects(extent)) {
        if (this.min.x > extent.min.x) {
            intersection.min.x = this.min.x;
        } else {
            intersection.min.x = extent.min.x;
        }
        if (this.min.y > extent.min.y) {
            intersection.min.y = this.min.y;
        } else {
            intersection.min.y = extent.min.y;
        }
        if (this.max.x < extent.max.x) {
            intersection.max.x = this.max.x;
        } else {
            intersection.max.x = extent.max.x;
        }
        if (this.max.y < extent.max.y) {
            intersection.max.y = this.max.y;
        } else {
            intersection.max.y = extent.max.y;
        }
    } else
        return null;
    return intersection;
};

se.Extent.prototype.getWidth = function() {
    return this.max.x - this.min.x;
}

se.Extent.prototype.getHeight = function() {
    return this.max.y - this.min.y;
}

/*
BoxRender
*/
se.RectRenderer = function(color, width, height){
    this.color = color;
    this.width = width;
    this.height = height;
}

se.RectRenderer.prototype.render = function(ctx){
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
}

se.RectRenderer.prototype.setParent = function(obj){
    this.parent = obj;
}

/*
CircleRender
*/
se.CircleRenderer = function(radius, fillStyle, strokeStyle, lineWidth){
    this.radius = radius;
    this.fillStyle = fillStyle;
    this.strokeStyle = strokeStyle;
    this.lineWidth = lineWidth || 1;
}

se.CircleRenderer.prototype.render = function(ctx){
    ctx.beginPath();

    ctx.fillStyle = this.fillStyle;
    if(this.strokeStyle){
        ctx.strokeStyle = this.strokeStyle;
        ctx.lineWidth = this.lineWidth;
    }

    ctx.arc(0, 0, this.radius, 0, 2 * Math.PI);
    ctx.fill();

    if(this.strokeStyle)
        ctx.stroke();
}

se.CircleRenderer.prototype.setParent = function(obj){
    this.parent = obj;
}

/*
ImageRender
*/

se.ImageRenderer = function(image_src, width, height){
    this.img = new Image();
    this.is_load = false;
    this.img.src = image_src;
    this.width = width;
    this.height = height;
}

se.ImageRenderer.prototype.render = function(ctx){
    ctx.drawImage(this.img, -this.width / 2, -this.height / 2, this.width, this.height);
}

se.ImageRenderer.prototype.setParent = function(obj){
    this.parent = obj;
}

/*
   GradientRenderer
*/
se.GradientRenderer = function(color1, color2){
    this.color1 = color1 || '#004CB3';
    this.color2 = color2 || '#8ED6FF';
}

se.GradientRenderer.prototype.setParent = function(obj){
    this.parent = obj;
}

se.GradientRenderer.prototype.render = function(ctx, params){
    var grd = ctx.createLinearGradient(150, 0, 150, 300);
    grd.addColorStop(0, this.color1);
    grd.addColorStop(1, this.color2);
    ctx.fillStyle = grd;
    ctx.fillRect(params.x, params.y, params.width, params.height);
}


/*
   RigidBodyRenderer - Based in Matter JS
*/
se.MeshRenderer = function(fillColor, strokeColor, lineWidth){
    this.color = color;
    this.strokeColor = strokeColor;
    this.lineWidth = lineWidth;
}

se.MeshRenderer.prototype.setParent = function(obj){
    this.parent = obj;
}

se.MeshRenderer.prototype.render = function(ctx){
    var pos = this.parent.transform.position;
    var part = this.parent.mesh;
    var c = ctx;

    // part polygon
    c.beginPath();

    for (var j = 1; j < part.vertices.length; j++) {
        var x = part.vertices[j].x - pos.x;
        var y = part.vertices[j].y - pos.y;
        if (!part.vertices[j - 1].isInternal || showInternalEdges) {
            c.lineTo(x, y);
        } else {
            c.moveTo(x, y);
        }

        if (part.vertices[j].isInternal && !showInternalEdges) {
            x = part.vertices[(j + 1) % part.vertices.length].x - pos.x;
            y = part.vertices[(j + 1) % part.vertices.length].y - pos.y;
            c.moveTo(x, y);
        }
    }

    c.lineTo(part.vertices[0].x - pos.x, part.vertices[0].y - pos.y);
    c.closePath();

    c.fillStyle = this.color;
    if(this.strokeStyle){
        c.lineWidth = this.lineWidth;
        c.strokeStyle = this.strokeStyle;
    }

    c.fill();
    c.stroke();

}
/*
    Joystick
*/
se.Joystick = function (){
    var x = 0;
    var y = 0;
    this.jump = false;
    this.keyhandler = new se.KeyboardHandler(this);
}

se.Joystick.prototype.getAxis = function (name){
    if(name == 'horizontal') return this.x;
    if(name == 'vertical') return this.y;    
    if(name == 'jump') return this.jump;
    return 0;
}

se.Joystick.prototype.setAxis = function (name, val){
    if(name == 'horizontal') 
        this.x = val;
    if(name == 'vertical') 
        this.y = val;    
    if(name == 'jump') 
        this.jump = val;
}

se.Joystick.prototype.resetAxis = function (){
    this.x = 0;
    this.y = 0;    
    this.jump = false;
}



/*
    KeyboardHandler
*/
se.KeyboardHandler = function (joystick){
    var self = this;
    this.joy = joystick;
    document.addEventListener('keydown', function(e){
        self.keydown(e.keyCode);
    });
    document.addEventListener('keyup', function(e){
        self.keyup(e.keyCode);
    });
}

se.KeyboardHandler.prototype.keydown = function(key){
    if (key == '65' || key == '37'){ // Left
        this.joy.setAxis('horizontal',-1);
    } else if (key == '68' || key == '39'){ // 'right'
        this.joy.setAxis('horizontal',1);
    } else if (key == '87'){ // Up
        this.joy.setAxis('vertical', -1);
    } else if (key == '83'){ // 'Down'
        this.joy.setAxis('vertical', 1);
    } else if (key == '32'){ // 'Space'
        this.joy.setAxis('jump', true);
    }
}

se.KeyboardHandler.prototype.keyup = function(key){
    if (key == '65' || key == '68' || key == '37' || key == '39'){
        this.joy.setAxis('horizontal',0);
    } else if (key == '87' || key == '83'){
        this.joy.setAxis('vertical', 0);
    } else if (key == '32'){
        this.joy.setAxis('jump', false);
    }
}

/*
    Mesh
*/
se.Mesh = function (parent, options){
    this.parent = parent;
    options = options || {};
    this.vertices = options.vertices || [];
    this._computeExtent();
};

se.Mesh.prototype.setVertices = function(vertices){
    this.vertices = vertices;
    this._computeExtent();
};

se.Mesh.prototype.getVertices = function(){
    return this.vertices;
};

se.Mesh.prototype.getExtent = function(){
    var obj = this.parent;
    return this.extent.clone().move(obj.transform.getXY());
};

se.Mesh.prototype._computeExtent = function(){
    this.extent = se.Extent.createEmpty();
    this.extent.extendVectors(this.vertices);
};
/*
    Scene
*/
se.Scene = function (parent, renderer){
    this.parent = parent;
    this.camera = new se.GameObject('MainCamera',0,0,0,0);
    this.pivot = new se.Transform(this, 0, 0);
    this.objs = [];
    this.colliders = [];
    this.add(this.camera);

    if(!renderer){
        this.renderer = new se.GradientRenderer('#8ED6FF','#004CB3');
        this.renderer.setParent(this);
    } else
        this.renderer = renderer;

    // create a Matter.js engine
    this.matterengine = Matter.Engine.create(this.parent.element);
    this.matterengine.enableSleeping = true;
};

se.Scene.prototype.getWidth = function(){
    return this.parent.getWidth();
};

se.Scene.prototype.getHeight = function(){
    return this.parent.getHeight();
};

se.Scene.prototype.getCamera = function(){
    return this.camera;
};

se.Scene.prototype.getObjs = function(){
    return this.objs;
};

se.Scene.prototype.setParent = function(parent){
    this.parent = parent;
};

se.Scene.prototype.add = function(obj){
    this.objs.push(obj);
    obj.setParent(this);
    if(obj.rigidbody)
        this.addBody(obj.rigidbody.body)
    this.addColliders(obj.getColliders());
};

se.Scene.prototype.addBody = function(body){
    var engine = this.matterengine;
    Matter.World.add(engine.world, body);
};

se.Scene.prototype.removeBody = function(body){
    var engine = this.matterengine;
    Matter.Composite.removeBody(engine.world, body);
};

se.Scene.prototype.addColliders = function(colliders){
    this.colliders.concat(colliders);
};

se.Scene.prototype.update = function(deltaTime, correction){
    Matter.Engine.update(this.matterengine, deltaTime, correction);
    this.checkColliders();
    for(var i in this.objs){
        var obj = this.objs[i];
        obj.update(deltaTime, correction);
    }
};

se.Scene.prototype.checkColliders = function(){
    var pairs = [];
    for(var i = 0; i < this.colliders.length -1; i++){
        var colA = this.colliders[i];
        for(var j = 1; j < this.colliders.length; j++){
            var colB = this.colliders[j];
            if(colA.isIntersect(colB))
                pairs.push([colA, colB]);
        }
    }
    for(var i in pairs){
        console.log(pairs[i])
    }
};

se.Scene.prototype.render = function(ctx){
    this.updatePivot(ctx);
    this.clearframe(ctx);
    this.renderBackground(ctx);
    for(var i in this.objs){
        this.objs[i].render(ctx);
    }
};

se.Scene.prototype.renderBackground = function(ctx){
    this.renderer.render(ctx, {
        x: this.pivot.position.x,
        y: this.pivot.position.y,
        width: this.getWidth(),
        height: this.getHeight()
    })
};

se.Scene.prototype.clearframe = function(ctx){
    ctx.clearRect(
        this.pivot.position.x,
        this.pivot.position.y,
        this.getWidth(),
        this.getHeight()
    );
};

se.Scene.prototype.updatePivot = function(ctx){
    // Reset draw
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    var position = this.camera.transform.position;

    var x = position.x - (this.getWidth() / 2);
    var y = position.y - (this.getHeight() / 2);
    this.pivot.change(x, y);
    ctx.translate(-x, -y);
};

se.Scene.prototype.resetCamera = function(){
    this.pivot.change(0, 0);
};
/*
    Star Engine
*/
se.StarEngine = function (elementID){
    var self = this;
    if(elementID)
        this.element = document.getElementById(elementID);
    else
        this.element = document.body;

    if (this.element.getContext){
        this.ctx = this.element.getContext('2d');
    }
    this.scenes = [];
    this.joystick = new se.Joystick();
    self.updateSize();

    window.addEventListener('resize',function(){
        self.getSceneCurrent().resetCamera();
        self.updateSize();
    });

    var defaults = {
        fps: 60,
        correction: 1,
        deltaSampleSize: 60,
        counterTimestamp: 0,
        frameCounter: 0,
        deltaHistory: [],
        timePrev: null,
        timeScalePrev: 1,
        frameRequestId: null,
        isFixed: false,
        enabled: true,
        timing: {
            timestamp: 0,
            timeScale: 1
        }
    };
    var runner = defaults;
    runner.delta = runner.delta || 1000 / runner.fps;
    runner.deltaMin = runner.deltaMin || 1000 / runner.fps;
    runner.deltaMax = runner.deltaMax || 1000 / (runner.fps * 0.5);
    runner.fps = 1000 / runner.delta;
    this.runner = runner;
};

se.StarEngine.prototype.getWidth = function(){
    return this.element.width;
};

se.StarEngine.prototype.getHeight = function(){
    return this.element.height;
};

se.StarEngine.prototype.getSceneCurrent = function(){
    return this.scenes[0];
};

se.StarEngine.prototype.setSize = function(width, height){
    this.element.width = width;
    this.element.height = height;
}

se.StarEngine.prototype.updateSize = function(){
    var ele = this.element;
    var parent = ele.parentElement;
    this.setSize(parent.offsetWidth, parent.offsetHeight);
}

se.StarEngine.prototype.getContext = function(){
    return this.ctx;
};

se.StarEngine.prototype.addScene = function(scene){
    this.scenes.push(scene);
    scene.setParent(this);
};

se.StarEngine.prototype.update = function(time){
    var runner = this.runner;

    var timing = runner.timing,
        correction = 1,
        delta;

    // create an event object
    var event = { timestamp: timing.timestamp };

    if (runner.isFixed) {
        // fixed timestep
        delta = runner.delta;
    } else {
        // dynamic timestep based on wall clock between calls
        delta = (time - runner.timePrev) || runner.delta;
        runner.timePrev = time;

        // optimistically filter delta over a few frames, to improve stability
        runner.deltaHistory.push(delta);
        runner.deltaHistory = runner.deltaHistory.slice(-runner.deltaSampleSize);
        delta = Math.min.apply(null, runner.deltaHistory);
        
        // limit delta
        delta = delta < runner.deltaMin ? runner.deltaMin : delta;
        delta = delta > runner.deltaMax ? runner.deltaMax : delta;

        // correction for delta
        correction = delta / runner.delta;

        // update engine timing object
        runner.delta = delta;
    }

    // time correction for time scaling
    if (runner.timeScalePrev !== 0)
        correction *= timing.timeScale / runner.timeScalePrev;

    if (timing.timeScale === 0)
        correction = 0;

    runner.timeScalePrev = timing.timeScale;
    runner.correction = correction;

    // fps counter
    runner.frameCounter += 1;
    if (time - runner.counterTimestamp >= 1000) {
        runner.fps = runner.frameCounter * ((time - runner.counterTimestamp) / 1000);
        runner.counterTimestamp = time;
        runner.frameCounter = 0;
    }


    var scene = this.getSceneCurrent();
    scene.update(delta, correction);
    scene.render(this.ctx);
};

se.StarEngine.prototype.run = function(){
    var runner = this.runner;
    var self = this;
    (function render(time){
        runner.frameRequestId = window.requestAnimationFrame(render);
        if (time && runner.enabled)
            self.update(time);
    })();

    return runner;
};

se.StarEngine.prototype.pause = function(status){
    if(status == null)
        status = true;
    this.runner.enabled = !status;
};



/*
    Collider
*/
se.RectCollider = function (x, y, width, height){
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
}

se.RectCollider.createByExtent = function(extent){
    return new se.RectCollider(
        extent.min.x, extent.min.y, extent.max.x, extent.max.y
    );
}

se.RectCollider.prototype.setParent = function(obj){
    this.parent = obj;
    this._computeExtent();
}

se.RectCollider.prototype._computeExtent = function(){
    this.extent = new se.Extent(
        this.x, this.y, this.x + this.width, this.y + this.height);
}


se.RectCollider.prototype.getExtent = function(){
    var obj = this.parent;
    return this.extent.clone().move(obj.transform.getXY());
}

se.RectCollider.prototype.isIntersect = function(collider){
    var extent1 = this.getExtent();
    var extent2 = collider.getExtent();
    console.log(extent1,extent2)
    return extent1.intersects(extent2);
}

se.RectCollider.prototype.getIntersection = function(collider){
    if(collider instanceof Array){
        for(var i in collider){
            var c = collider[i];
            if(this._isIntersect(c))
                return this._getIntersection(c);
        }
    } else
        return this._getIntersection(collider);
    return null;
}

se.RectCollider.prototype._getIntersection = function(collider){
    var extent1 = this.getExtent();
    var extent2 = collider.getExtent();
    return extent1.getIntersection(extent2);
}

se.RectCollider.prototype.clone = function(){
    return new se.RectCollider(this.x, this.y, this.width, this.height);
}



/*
   Rigid Body based in matter
*/
se.RigidBody = function (options){
    this.options = options;
};

se.RigidBody.prototype.createBody = function (){
    var obj = this.parent;
    var pos = obj.transform.position;
    options = this.options || {};
    var x = options.x || pos.x;
    var y = options.y || pos.y;

    this.isPermeable = options.isPermeable != null ? options.isPermeable : false;

    delete options.x;
    delete options.y;
    delete options.isPermeable;

    options.isStatic = obj.isStatic;
    options.canRotate = obj.canRotate;


    var body = {
        label: 'Rectangle Body',
        position: { x: x, y: y },
        vertices: obj.mesh.getVertices()
    };
    this.body = Matter.Body.create(Matter.Common.extend({}, body, options));
};

se.RigidBody.prototype.update = function (deltaTime){
    var pos = this.parent.transform.position;
    pos.x = this.body.position.x;
    pos.y = this.body.position.y;
    this.parent.angle = this.body.angle;
};

se.RigidBody.prototype.setParent = function (parent){
    this.parent = parent;
    this.createBody();
};

se.RigidBody.prototype.setPermeable = function (isPermeable){
    var scene = this.parent.getScene();
    if(isPermeable == true && this.isPermeable == false)
        scene.removeBody(this.body);
    else if(isPermeable == false && this.isPermeable == true)
        scene.addBody(this.body);
    this.isPermeable = isPermeable;
};

se.RigidBody.prototype.setVelocity = function (velocity){
    Matter.Sleeping.set(this.body,false); // Wake up Object
    Matter.Body.setVelocity(this.body, velocity);
};

se.RigidBody.prototype.applyForce = function (position, force){
    Matter.Body.applyForce(this.body, position, force);
};

se.RigidBody.prototype.setAngularVelocity = function (velocity){
    Matter.Body.setAngularVelocity(this.body, velocity);
};

Matter.Body.update = function(body, deltaTime, timeScale, correction) {
    var Bounds = Matter.Bounds;
    var Vector = Matter.Vector;
    var Vertices = Matter.Vertices;
    var Axes = Matter.Axes;

    var deltaTimeSquared = Math.pow(deltaTime * timeScale * body.timeScale, 2);

    // from the previous step
    var frictionAir = 1 - body.frictionAir * timeScale * body.timeScale,
        velocityPrevX = body.position.x - body.positionPrev.x,
        velocityPrevY = body.position.y - body.positionPrev.y;

    // update velocity with Verlet integration
    body.velocity.x = (velocityPrevX * frictionAir * correction) + (body.force.x / body.mass) * deltaTimeSquared;
    body.velocity.y = (velocityPrevY * frictionAir * correction) + (body.force.y / body.mass) * deltaTimeSquared;

    body.positionPrev.x = body.position.x;
    body.positionPrev.y = body.position.y;
    body.position.x += body.velocity.x;
    body.position.y += body.velocity.y;

    // Custom to no rotate
    // update angular velocity with Verlet integration
    if(body.canRotate)
        body.angularVelocity = ((body.angle - body.anglePrev) * frictionAir * correction) + (body.torque / body.inertia) * deltaTimeSquared;
    else
        body.angularVelocity = 0;

    body.anglePrev = body.angle;
    body.angle += body.angularVelocity;

    // track speed and acceleration
    body.speed = Vector.magnitude(body.velocity);
    body.angularSpeed = Math.abs(body.angularVelocity);

    // transform the body geometry
    for (var i = 0; i < body.parts.length; i++) {
        var part = body.parts[i];

        Vertices.translate(part.vertices, body.velocity);

        if (i > 0) {
            part.position.x += body.velocity.x;
            part.position.y += body.velocity.y;
        }

        if (body.angularVelocity !== 0) {
            Vertices.rotate(part.vertices, body.angularVelocity, body.position);
            Axes.rotate(part.axes, body.angularVelocity);
            if (i > 0) {
                Vector.rotateAbout(part.position, body.angularVelocity, body.position, part.position);
            }
        }

        Bounds.update(part.bounds, part.vertices, body.velocity);
    }
};
/*
   Vector
*/
se.Vector = function (x, y){
    this.x = x;
    this.y = y;
};

se.Vector.prototype.equals = function(other){
    return (this.x == other.x && this.y == other.y);
};

se.Vector.prototype.clone = function(){
    return new se.Vector(this.x, this.y);
};

se.Vector.prototype.change = function (x, y){
    this.x = x;
    this.y = y;
};

se.Vector.prototype.getMagnitude = function (){
    return Math.sqrt((this.x * this.x) + (this.y * this.y));
};

se.Vector.prototype.sub = function (other, is_self){
    var out;
    if(is_self)
        out = this;
    else
        out = new se.Vector(0, 0);
    out.x = this.x - other.x;
    out.y = this.y - other.y;
    return out;
};

se.Vector.prototype.add = function (other, is_self){
    var out;
    if(is_self)
        out = this;
    else
        out = new se.Vector(0, 0);
    out.x = this.x + other.x;
    out.y = this.y + other.y;
    return out;
}
/*
    ComponentScript
*/
se.ComponentScript = function (function_update){
    this.update = function_update;
};
se.ComponentScript.prototype.setParent = function(obj){
    this.parent = obj;
}

/*
    ComponentPlatformPlayerController
*/
se.ComponentPlatformPlayerController = function (joystick, speed, jumpspeed, gravity){
    this.joystick = joystick;
    this.speed = speed;
};

se.ComponentPlatformPlayerController.prototype.update = function(obj, deltaTime){
    var x = this.joystick.getAxis('horizontal') * deltaTime / 10;
    x = x || 0;
    var jump = this.joystick.getAxis('jump')
    if(x || jump){
        var vel = obj.rigidbody.body.velocity;
        var x = vel.x + x;
        var y = vel.y;
        if(x > 0)
            obj.transform.rotate.x = 1;
        else if (x < 0)
            obj.transform.rotate.x = -1;
        if(x > 16)
            x = 16;
        if(x < -16)
            x = -16;
        if(jump && vel.y < 1 && vel.y > -1){
            y = -13;
        }
        obj.rigidbody.setVelocity({x: x, y: y});
    }
};

se.ComponentPlatformPlayerController.prototype.setParent = function(obj){
    this.parent = obj;
}


/*
    ComponentFollowPlayer
*/
se.ComponentFollowObject = function (obj_target){
    this.obj_target = obj_target;
}
se.ComponentFollowObject.prototype.update = function(obj){
    obj.transform.position.x = this.obj_target.transform.position.x;
    obj.transform.position.y = this.obj_target.transform.position.y;
}
se.ComponentFollowObject.prototype.setParent = function(obj){
    this.parent = obj;
}



/*
    GameObject
*/
se.GameObject = function (name, x, y, options){
    this.name = name;
    this.transform = new se.Transform(this, x, y);
    this.components = [];
    this.colliders = [];
    this.renderer = null;
    this.parent = null;
    this.children = [];

    options = options || {};
    this.isStatic = options.isStatic != null ? options.isStatic : false;
    this.isSleeping = options.isSleeping || false;
    this.canRotate = options.canRotate != null ? options.canRotate : true;

    this.mesh = options.mesh || new se.Mesh(this, {vertices: options.vertices});
    this.rigidbody = options.rigidbody || null;
    this.angle = 0;
};

se.GameObject.prototype.getX = function(){
    return this.transform.position.x;
};

se.GameObject.prototype.getY = function(){
    return this.transform.position.y;
};

se.GameObject.prototype.getWidth = function(){
    return this.width;
};

se.GameObject.prototype.getHeight = function(){
    return this.height;
};

se.GameObject.prototype.getScene = function(){
    var parent = this.parent;
    while(parent != null && parent instanceof se.Scene == false)
        parent = parent.parent;
    return parent;
};

se.GameObject.prototype.getColliders = function(){
    return this.colliders;
};

se.GameObject.prototype.setRenderer = function(renderer){
    renderer.setParent(this);
    this.renderer = renderer;
};

se.GameObject.prototype.update = function(deltaTime, correction){
    var rb = this.rigidbody;
    if(rb)
        this.rigidbody.update(deltaTime, correction);
    for(var i in this.components){
        this.components[i].update(this, deltaTime, correction);
    }
    for(var i in this.children){
        this.children[i].update(deltaTime, correction);
    }
};

se.GameObject.prototype.render = function(ctx){
    var obj = this;
    var pos = obj.transform.position;
    var r = obj.transform.rotate;

    ctx.translate(pos.x, pos.y);
    //ctx.rotate(r.y*Math.PI/180);
    ctx.rotate(obj.angle);
    ctx.scale(r.x, 1);

    if(this.renderer) this.renderer.render(ctx);
    for(var i in this.children){
        this.children[i].render(ctx);
    }

    // Reset
    ctx.scale(r.x, 1);
    //ctx.rotate(-r.y*Math.PI/180);
    ctx.rotate(-obj.angle);
    ctx.translate(-pos.x, -pos.y);
};

se.GameObject.prototype.addComponent = function(component){
    this.components.push(component);
    component.setParent(this);
    return this;
};

se.GameObject.prototype.addCollider = function(collider){
    this.colliders.push(collider);
    collider.setParent(this);
    return this;
};

se.GameObject.prototype.setRigidBody = function(rigidbody){
    this.rigidbody = rigidbody;
    rigidbody.setParent(this);
    return this;
};

se.GameObject.prototype.setParent = function (parent){
    this.parent = parent;
};

se.GameObject.prototype.addChild = function (child){
    this.children.push(child);
    child.setParent(this);
};


/*
    Transform
*/
se.Transform = function(parent, x, y){
    this.parent = parent;
    this.position = new se.Vector(x, y);
    this.rotate = new se.Vector(1, 0);
};

se.Transform.prototype.change = function(x,y){
    this.position.change(x, y);
};

se.Transform.prototype.move = function(x,y){
    this.position.x += x;
    this.position.y += y;
    this.resolveCollision(x, y);
};

se.Transform.prototype.getXY = function(){
    var x = this.position.x;
    var y = this.position.y;

    var obj = this.parent;
    var parent = obj.parent;
    if(parent instanceof se.GameObject){
        x += parent.transform.position.x;
        y += parent.transform.position.y;
    }

    return {x: x, y: y};
};

